---
title: 아키텍쳐개념 - 1. Request Lifecycle
categories: [Laravel, 문서(11.x), 아키텍쳐개념]
---


## Request-요청 라이프사이클

### 첫번째 단계
라라벨 애플리케이션의 모든 요청에 대한 시작점은 `public/index.php` 파일입니다. 웹서버 설정에 따라 모든 요청은 이 파일에 전달됩니다.
`index.php` 파일은 그다지 많은 코드를 가지고 있지 않습니다. 대신 프레임워크의 나머지 부분들을 로딩하기 위한 시작점이 됩니다.

`index.php` 파일은 컴포저가 생성한 오토로더 정의를 로딩합니다. 그리고 `bootstraip/app`에서 라라벨 애플리케이션의 인스턴스를 가져옵니다. 
라라벨 자신의 첫번째 동작은 <a href="https://laravel.com/docs/11.x/container" target="_blank">서비스 컨테이너</a> 인스턴스를 생성하는 것 입니다.


### HTTP / Console 커널
들어오는 요청은 애플리케이션에 도착하는 요청의 종류에 따라 애플리케이션의 특정 메소드를 사용해 HTTP 커널이나 Console 커널로 보내집니다. 이 커널들은 모든 요청이 거처가는 중심 지점 역활을 합니다.
우리는 지금 HTTP 커널에 초점을 맞출 건데, 이는 `Illuminate\Foundation\Http\Kernel`에 해당하는 부분입니다.
간단히 말해서, 애플리케이션이 웹 요청이나 명령어 요청을 받을 때, 이를 적절히 처리하기 위해 HTTP커널 또는 Console 커널로 전달합니다. 이 과정에서 HTTP 커널은 웹 요청을 다루며, 이는 Laravel이 미리 정해 둔 규칙과 절차에 따라 요청을 처리하는 부분입니다.

HTTP 커널은 요청이 실행되기 전에 실행될 `bootstrappers` 배열을 정의하는 `Illuminate\Foundation\Http\Kernel` 클래스를 확장합니다. 이러한 부트스트래퍼는 오류 처리를 구성하고, 로깅을 구성하고, <a href="https://laravel.com/docs/11.x/configuration#environment-configuration" target="_blank">애플리케이션 환경을 감지</a>하고 요청이 실제로 처리되기 전에 수행해야 하는 기타 작업을 수행합니다. 일반적으로 이러하느 클래스는 신경 쓸 필요가 없는 라라벨 내부 설정을 처리합니다. 

HTTP 커널은 또한 모든 요청이 애플리케이션에서 처리되기 전에 통과해야 하는 HTTP 미들웨어 목록을 관리합니다. 이러한 미들웨어는 <a href="https://laravel.com/docs/11.x/session" _target="blank">HTTP 세션</a> 읽기 및 쓰기, 애플리케이션이 유지관리 모드에 있는지 확인, <a href="https://laravel.com/docs/11.x/csrf" target="_blank">CSRF 토큰 확인</a> 등을 처리합니다. 

HTTP 커널의 `handle` 메서드에 대한 메서드 사용법은 매우 간단합니다. `Request`를 수신하고 `Response`을 반환 합니다. 커널을 전체 애플리케이션을 나타내는 큰 블랙박스로 생각하십시오. HTTP 요청을 제공하면 HTTP 응답을 반환합니다.

요약) HTTP 커널: 오류처리구성 + 로깅구성 + 애플리케이션 환경 감지 + 기타작업 수행. + 미들웨어 목록을 관리(HTTP 세션, 유지관리모드 확인, CSREF 토큰 확인). 
                  요청 -> 응답.


### 서비스 프로바이더-Service Providers
커널 부스트래핑 작업 중 가장 중요한 것은 애플리케이션을 위한 [서비스 프로바이더(제공자)](https://laravel.com/docs/11.x/providers){: target="_blank"}를 로딩하는 것입니다.
서비스 프로바이더는 데이터베이스 큐, 유효성검사, 라우팅과 같은 프레임워크의 다양한 구성 컴포넌트(구성요소)를 부트스트래핑(시작과 실행)하는 일을 담당합니다.

라라벨은 이 프로바이더 목록을 순회하며 각각을 인스턴스화 합니다. 
프로바이더를 인스턴스화한 후 모든 프로바이더에 대해 `register`메소드가 호출됩니다. 
그런 다음 모든 프로바이더가 등록되면 각 프로바이더에 대해 `boot` 메소드가 호출됩니다.
이는 서비스 프로바이더가 `boot` 메소드가 실행될 때, 등록되고 사용 가능한 모든 컨테이너 바인딩에 의존할 수 있기 때문입니다.

프레임워크 내부적으로 수십 개의 서비스 프로바이더를 사용하는 동안, 여러분도 자신만의 서비스 프로바이더를 만들 수 있는 옵션이 있습니다.
여러분의 애플리케이션이 사용하는 사용자 정의 또는 제3자 서비스 프로바이더 목록은 `bootstrap/providers.php` 파일에서 확인 할 수 있습니다.


### 라우팅
애플리케이션이 부트스트랩되고 모든 서비스 프로바이더가 등록되면, `Request`은 라우터에게 전달되어 디스패치 됩니다. 

미들웨어는 애플리케이션에 들어오는 HTTP 요청을 필터링하거나 검사하기 위한 편리한 메커니즘을 제공합니다. 예를 들어, 라라벨에서는 애플리케이션 사용자가 인증되었는지 확인하는 미들웨어가 포함되어 있습니다. 
사용자가 인증되지 않은 경우 미들웨어는 사용자를 로그인 화면으로 리다이렉션합니다. 그러나 사용자가 인증되면 미들웨어는 요청이 애플리케이션으로 더 진행되도록 허용해 줍니다. 
일부 미들웨어는 HTTP 커널의 `middleware` 속성에 정의된 것과 같이 애플리케이션 내의 모든 경로에 할당되는 반면 일부는 특정 경로 또는 경로 그룹에만 할당됩니다. 
전체 [미들웨어 문서](https://laravel.com/docs/11.x/middleware){: target="_blank"}를 읽으면 미들웨어에 대해 자세히 알아볼 수 있습니다.

요청이 일치하는 경로에 할당된 모든 미들웨어를 통과하면 경로 또는 컨트롤러 메서드가 실행되고 경로 또는 컨트롤러 메서드에서 반환된 응답은 경로의 미들웨어 체인을 통해 다시 전송됩니다.


### 마무리
경로 또는 컨트롤러 메소드가 응답을 반환하면, 이 응답은 경로의 미들웨어를 통해 바깥쪽으로 다시 이동하게 되며, 이 과정에서 애플리케이션이 나가는 응답을 수정하거나 검사할 기회를 갖게 됩니다.


## 서비스 프로바이더 추가 설명
서비스 프로바이더는 라라벨 애플리케이션의 부팅(부트스트래핑) 단계의 주요한 핵심입니다. 애플리케이션의 인스턴스가 생성되고, 서비스 프로바이더가 등록된 후 부트스트래핑 과정을 마친 프로그램이 요청을 처리합니다. 매우 간단!

라라벨 애플리케이션이 어떻게 구성되어 있는지 서비스 프로바이더를 통해 부트스트랩되는 과정을 구체적으로 이해하는 것은 매우 중요합니다. 
여러분의 애플리케이션을 위한 기본 서비스 프로바이더는 `app/Providers` 디렉토리에 있습니다.

기본적으로 `AppServiceProvider`는 거의 빈채로 만들어져 있습니다. 이 프로바이더는 여러분의 고유한 부트스트래핑과 서비스 컨테이너 바인딩 코드를 추가하기 위한 곳 입니다. 
대규모 애플리케이션의 경우, 애플리케이션에서 사용하는 특정 서비스에 대해 더 세분화된 부트스트래핑을 관리하는 여러개의 서비스 공급자를 만들 수 있습니다.


![LifeCycle](/imgs/develop/laravel/doc/lifecycle.webp)
