---
title: 아두이노 멀티탭 제어(소프트웨어)
date: 2026-02-20
categories: [Arduino, Multitab]
---

## 플로우차트
![플로우차트](/imgs/develop/etcs/arduino-muititab-on_off-flowchart.png)


## 프론트엔드
### 로그인
```vue
<script setup>
import { reactive } from 'vue';
import * as api from '@/api';
import { useAuthStore } from '@/store/auth';

const authStore   = useAuthStore();

const params = reactive({
  'admin_id': '',
  'admin_pw': '',
})
const login = async() => {

  

  try {

    const res   = await api.post('/api/login', params);
    const accessToken   = res.data.accessToken;
    authStore.setAccessToken(accessToken);
    
    // router.push(goUrl);
  
  }
  catch(ex) {
    console.error(ex);
  });
  
}
</script>
```


### 전송
```vue
<script setup>
import { ref } from 'vue'
import * as from '@/api';

const on_off = ref(0);
const now_state = ref();

const on_off_toggle = async() => {
  try {
    await api.get('/api/power/control', {cmd: on_off})
    .then(async(res) => {
      now_state = res.data.state
      on_off = on_off == 0 ? 1 : 0;
    });
  }
  catch((ex) => {
    console.error(ex);
  });
}

const get_status = async() => {
  try {
    await api.get('/api/power/status')
    .then(async(res) => {
      now_state = res.data.state
    });
  }
  catch((ex) => {
    console.error(ex);
  });
}

const onMount = async() => {
  await get_status();
}
</script>
```

## 백엔드(Laravel)
```php
use Illuminate\Support\Facades\Http;

public function powerOnOff(Request $request)
{

  $cmd  = $request->input('cmd');

  $powerControllerPcUrl   = 'https://제어pc도메인:포트';

  try {
    $response = Http::timeout(3)->withToken(auth('api-admin'))->get($powerControllerPcUrl, ['cmd' => $cmd]);

    if ($response->successful()) {
      return response()->json([
        'status' => 'success'
      ]);
    }
    else {

    }
  }
  catch(\Exception $e){

      return response()->json([
        'status' => 'error',
        'message' => $e->getMessage(),
      ], 500);
  }
}

```


## 제어PC
 주요 기능
  - 파이썬을 통해 제어
  - SSL 적용(Sectigo)
  - JWT 토큰 인증

### SSL 인증서
#### 1. 인증서 준비
Sectigo에서 인증서를 발급 받으면 보통 다음과 같은 파일을 얻게된다.
```
 /
  - domain.all.crt.pem
  - domain.crt.pem
  - domain.key.pem
 /RootChain
  - chain-bundle.pem
  - root-chain-bundle.pem
  - Sectigo Public Server Authentication CA DV R36.crt.pem
  - Sectigo Public Server Authentication Root R46.crt.pem
```
여기서 필요한 파일은 `domain.all.crt.pem`과 `domain.key.pem` 두개 뿐이다.


```python
from flask import Flask, request, jsonify
# from flask_cors import CORS
from flask_jwt_extended import JWTManager, jwt_required
import serial
import time

app = Flask(__name__)
# 실 서비스에는 `origins`를 실제 도메인으로(api.example.com)
# 백그라운드에서 처리하므로 CORS 설정이 필요 없음.
# CORS(app, resources={r"/api/*": {"origins": "*"}})

app.config['JWT_SECRET_KEY'] = '운영서버 비밀키'
jwt = JWTManager(app)

# 화이트 리스트
ALLOWED_IPS = ['127.0.0.1', '실제 서버 IP']

@app.before_request
def limit_remote_addr():
  if request.remote_addr not in ALLOWED_IPS:
    return jsonify({"msg": "Forbidden: 허용되지 않은 IP입니다."}), 403



try:
    ser = serial.Serial()
    ser.port = 'COM3'
    ser.baudrate = 9600

    ser.setDTR(False)
    ser.open()

except:
    ser = None
    print("아두이노 연결 상태를 확인하세요.")

# 아두이노에 명령을 보내고 응답(상태)을 읽어오는 함수
def get_arduino_state(command):
    if ser is not None:
        ser.reset_input_buffer() # 기존 버퍼 비우기
        ser.write(command.encode())
        time.sleep(0.1) # 아두이노가 응답할 시간 대기
        if ser.in_waiting > 0:
            # 아두이노가 보낸 'ON' 또는 'OFF' 텍스트를 읽어옴
            state = ser.readline().decode('utf-8').strip()
            return state
    return "UNKNOWN"

# API 라우트
@app.route('/api/status', methods=['GET'])
def get_status():
    # '2'를 보내 실제 상태 조회
    actual_state = get_arduino_state('2')
    return jsonify({"status": "success", "state": actual_state})

@app.route('/api/control', methods=['GET'])
def control():
    cmd = request.args.get('cmd')
    
    if cmd in ['0', '1']:
        # '0' 또는 '1' 전송 후 변경된 상태 읽어옴
        actual_state = get_arduino_state(cmd)
        return jsonify({"status": "success", "state": actual_state})
            
    return jsonify({"status": "fail", "message": "Invalid command or Serial unconnected"})

if __name__ == '__main__':
    print("서버 시작.")

    ssl_cert_path = 'domain.all.crt.pem'
    ssl_key_path = 'domain.key.pem'
    app.run(
      host='0.0.0.0', port=5000,
      ssl_context=(ssl_cert_path, ssl_key_path)
    )
```


프론트엔드는 vueJS로 구현
```vueJS

```

