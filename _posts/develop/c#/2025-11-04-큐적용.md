---
title: 데이터 꼬임 방지를 위한 큐 적용
categories: [C#, C# 개발]
tags: [C#, Queue]
---

바코드리더기에서 1)바코드를 읽고, 2)사진을 찍고, 3)AI가 부위를 분석하고, 4)중량을 잰 최종 결과를 5)라벨프린터기로 프린트 한다.
위의 프로세스 중간에 다시 바코드리더기에 새로운 바코드가 읽히면 최종 5)라벨 프린터에서는 새로운 바코드 출력되는 문제가 발생.

이 문제의 원인을 **경합조건**이라 한다. 이 경합조건을 해결하기 위해서는 큐를 도입해야 한다.

```C#
// MainForm.cs
public partial class MainForm : Form
{
    // 1. 모든 작업이 이 '공유 변수'를 참조.
    private string cCode; // 현재 처리 중인 바코드

    // 2. 바코드 스캔 이벤트 (빠르게 여러 번 호출될 수 있음)
    private void BarcodeData(object sender, SerialDataReceivedEventArgs e)
    {
        // ... 바코드 파싱 ...
        string barcode = "1000"; // (1) '1000' 스캔

        // 3. 공유 변수 'cCode'에 값을 덮어 씀.
        this.cCode = barcode; 

        // 4. 'async void'로 작업을 "일단" 시작.
        this.MainProcess(); // (1) "1000" 작업 시작
    }

    // 5. 실제 처리 로직
    private async void MainProcess()
    {
        // (1) "1000"으로 촬영 시작
        await cameraControl.TakePicture(this.cCode + "_before.jpg"); 

        // (2) 'await'으로 대기하는 동안, BarcodeData 이벤트가 다시 호출될 수 있다.
        // (3) 두 번째 스캔 "1001"이 들어 옴!
        // (4) BarcodeData가 실행되어 공유 변수 'cCode'는 "1001"로 덮어 쓰여짐.

        // (5) '1000'번 작업이 깨어나서 다음 로직을 실행함.
        //     하지만 'this.cCode'는 이미 "1001"로 오염되어 있다.
        await CallAiApi(this.cCode); // "1001"로 AI 분석 요청 (문제 발생!)
        PrintLabel(this.cCode);      // "1001"로 출력 (문제 발생!)
    }
}
```
위 소스의 문제점은 *async void* 이벤트 핸들러가 *await*을 만나 대기하는 순간(await cameraControl.TakePicture),
UI 스레드는 다음 이벤트를 받을 준비를 한다. 이때 다음 바코드 스캔이 들어오면, *cCode*라는 공유변수의 값을 덮어쓰게 된다.

이 문제를 해결하기 위한 해결책으로는 '생산자-소비자' 큐(Queue) 패턴을 도입해야 한다.
  - 생산자(Producer): 바코드리더기
  - 소비자(Consumer): 백그라운다 즉업자. **큐**를 감시하다가, 작업이 들어오면 `하나씩 순서대로` 꺼내서 (촬영 -> AI -> 중량 -> 출력) 과정을 끝낸다.

C#에서는 이 패턴을 위해 **BlockingCollection<T>** 이라는 동시성 컬렉션을 제공한다.


#### 1단계: 네임스페이스 및 필드 추가
MainForm.cs 상단에 `System.Collections.Concurrent`를 추가하고, 큐와 작업자(Task)를 위한 필드를 선언한다.
```C#
using System.Collections.Concurrent;  // 스레드 안전 큐를 위해 추가

namespace MyProject
{
  public partial class MainForm : Form
  {

    private readonly BlockingCollection<string> _barcodeQueue = new BlockingCollection<string>();
    private readonly CancellationTokenSource _cts = new CancellationTokenSource();  // 폼 종료시 작업 취소를 위해
    private Task _barcodeProcessorTask; // 큐를 처리할 소비자(Consumer) 태스크

```


#### 2단계: `MainForm_Load` 수정 (소비자 시작)
폼이 로드될 때, 큐를 감시할 '소비자' 작업을 백그라운드 스레드에서 시작 시킨다.
```C#
  privatew async void MainForm_Load(object sender, EventArgs e)
  {
    // 소비자 작업을 백그라운드 스레드에서 시작 시킨다.
    _barcodeProcessorTask   = Task.Run(() => MainProcessQueueAsync(), _cts.Token);
  }
```

#### 3단계: `BarcodeData` (생산자) 수정
```C#
  private void BarcodeData(object sender, SerialDataRecivedEventArgs e)
  {
    Thread.Sleep(100);  // 포트 안정화를 위한 텔레이

    SerialPort sp = (SerialPort)sender;
    string data   = sp.ReadExisting();

    // ... 

    string barcodeData;
    string localCCode;  // 공유변수 cCode 대신 로컬 변수 사용

    lock(barcodeBufferLock)
    {
      // ...
      localCCode  = lastEntry.Trim();   // 로컬 변수에 저장
      barcodeBuffer.Clear();
    }
    
    // 이하 바코드 유효성 검사
    // ...

    // 유효성 검사 통과 시, 큐에 작업 추가
    if (!_barcodeQueue.IsAddingCompleted) {
      _barcodeQueue.Add(localCCode);
    }

  }
```

#### 4단계: `MainProcessQueueAsync` (소비자) 구현
기존 `MainProcess`의 로직을 가져와, 큐에서 작업을 꺼내 처리하는 `while` 루프를 만듬.
```C#

  private async Task MainProcessQueueAsync()
  {
    while(!_cts.Token.IsCancellationRequested)
    {
      // 큐에서 꺼내올 바코드
      string barcodeToProcess   = null;

      try
      {
        // 큐에서 작업을 꺼냄.
        // 큐가 비어있으면 새 작업이 들어올 때 까지 여기서 '대기'
        barcodeToProcess  = _barcodeQueue.Take(_cts.Token);

        // 기존 작업
        // ... 



      }
      catch(OperationCanceledException)
      {
        // 사용자가 작업 취소 시
        Console.WriteLine("작업 큐가 정상적으로 종료 됨.");
        break;
      }
      catch(Exception ex)
      {
        // 오류 종류에 따른 처리
        Console.WriteLine("[오류] 바코드: {barcodeToProcess}: {ex.Message}";)
        // 오류를 남기고 finally 로 이동

      }
      finally
      {
        this.Invoke((MethodInvoker)delegate{
          // 카메라 라이브 뷰등을 다시 시작
        });
        Console.WriteLine("======= {barcodeToProcess} 처리 끝 ===");
      }

    }
  }

```

#### 5단계: `MainForm_FormClosing` 종료처리
```C#

  private async void MainForm_FormClosing(object sender, FormClosingEventArgs e)
  {

    // 큐 작업자에게 취소 요청
    _cts.Cancel();

    // ... 기타 쓰레드 정리

    // 큐 작업자 정리
    if (_barcodeProcessorTask != null) {
      try {
      
      }
      catch(OperationCancelException) {
        // 정상종료
      }
      catch(Exception ex) 
      {
        // 종료 오류
        Console.WriteLine("종료 중 오루 밸상: {ex.Message}");
      }
    }

    e.Cancel  = false;  // 종료 작업 완료

    Application.ExitThread();
    Application.Exit();
    Environment.Exit(0);

  }

```
